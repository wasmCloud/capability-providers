//!
//! The httpserver capability provider allows wasmcloud actors to receive
//! and process http(s) messages from web browsers, command-line tools
//! such as curl, and other http clients. The server is fully asynchronous,
//! and built on Rust's high-performance warp engine, which is in turn based
//! on hyper, and can process a large number of simultaneous connections.
//!
//! ## Features:
//!
//! - HTTP/1 and HTTP/2
//! - TLS
//! - CORS support (select allowed_origins, allowed_methods,
//!   allowed_headers.) Cors has sensible defaults so it should
//!   work as-is for development purposes, and may need refinement
//!   for production if a more secure configuration is required.
//! - All settings can be specified at runtime, using per-actor link settings:
//!   - bind interface/port
//!   - logging level
//!   - TLS
//!   - Cors
//! - Flexible confiuration loading: from host, or from local toml or json file.
//! - Fully asynchronous, using tokio lightweight "green" threads
//! - Thread pool (for managing a pool of OS threads). The default
//!   thread pool has one thread per cpu core.
//! - Packaged as a rust library crate for implementation flexibility
//!
//! ## More tech info:
//!
//! Each actor that links to this provider gets
//! its own bind address (interface ip and port) and a lightweight
//! tokio thread (lighter weight than an OS thread, more like "green threads").
//! Tokio can manage a thread pool (of OS threads) to be shared
//! by the all of the server green threads.
//!
use std::{convert::Infallible, sync::Arc};

use bytes::Bytes;
use http::header::HeaderMap;
use thiserror::Error as ThisError;
use tokio::{
    sync::{oneshot, RwLock},
    task::JoinHandle,
};
use tracing::{error, info, instrument, Instrument, trace, warn};
use warp::{path::FullPath, Filter };
use wasmbus_rpc::{common::Context, core::LinkDefinition, error::RpcError, provider::*};
use wasmcloud_interface_httpserver::{HttpRequest, HttpResponse, HttpServer, HttpServerSender};

mod settings;
pub use settings::{load_settings, ServiceSettings};
mod hashmap_ci;
pub(crate) use hashmap_ci::make_case_insensitive;

/// errors generated by this crate
#[derive(ThisError, Debug)]
pub enum Error {
    #[error("invalid parameter: {0}")]
    InvalidParameter(String),

    #[error("problem reading settings: {0}")]
    Settings(String),

    #[error("provider startup: {0}")]
    Init(String),

    #[error("warp error: {0}")]
    Warp(warp::Error),

    #[error("deserializing settings: {0}")]
    SettingsToml(toml::de::Error),
}

struct Inner {
    settings: ServiceSettings,
    signal: Option<oneshot::Sender<bool>>,
    bridge: &'static HostBridge,
}

/// An asynchronous HttpServer with support for CORS and TLS
/// ```no_test
///   use wasmcloud_provider_httpserver::{HttpServer, load_settings};
///   let settings = load_settings(ld.values)?;
///   let server = HttpServer::new(settings);
///   let task = server.serve()?;
///   tokio::task::spawn(task);
/// ```
#[derive(Clone)]
pub struct HttpServerCore {
    inner: Arc<RwLock<Inner>>,
}

impl HttpServerCore {
    /// Initializes server with settings
    pub fn new(settings: ServiceSettings, bridge: &'static HostBridge) -> Self {
        Self {
            inner: Arc::new(RwLock::new(Inner {
                settings,
                signal: None,
                bridge,
            })),
        }
    }

    /// Initiate server shutdown. This can be called from any thread and is non-blocking.
    pub async fn begin_shutdown(&self) {
        let mut mut_sig = self.inner.write().await;
        let sig = mut_sig.signal.take();
        if let Some(sig) = sig {
            if sig.send(true).is_err() {
                // might not see this error if logging isn't initialized on this thread.
                // only relevant if the shutdown fails
                error!("failed sending shutdown signal to main thread");
            }
        }
    }

    /// Start the server in a new thread
    /// ```no_test
    ///    use wasmcloud_provider_httpserver::{HttpServer, load_settings};
    ///    let settings = load_settings(&ld.values)?;
    ///    let server = HttpServer::new(settings);
    ///    let _ = server.start().await?;
    /// ```
    pub async fn start(&self, ld: LinkDefinition) -> Result<JoinHandle<()>, Error> {
        let (shutdown_tx, shutdown_rx) = oneshot::channel();
        let inner = Arc::clone(&self.inner);
        {
            let mut update = inner.write().await;
            update.signal = Some(shutdown_tx);
        }
        let timeout = {
            let rd = self.inner.read().await;
            rd.settings.timeout_ms.map(std::time::Duration::from_millis)
        };

        let linkdefs = ld.clone();
        let actor_id = ld.actor_id.clone();
        let route = warp::any()
            .and(warp::header::headers_cloned())
            .and(warp::method())
            .and(warp::body::bytes())
            .and(warp::path::full())
            .and(opt_raw_query())
            .and_then(
                move |headers: HeaderMap,
                      method: http::method::Method,
                      body: Bytes,
                      path: FullPath,
                      query: String| {
                    let inner = Arc::clone(&inner);
                    let linkdefs = linkdefs.clone();
                    //let tracer = opentelemetry::global::tracer("HttpServer");
                    let span = tracing::debug_span!("http request");
                    span.record("method", &tracing::field::display(method.to_string().as_str()));
                    span.record("path", &tracing::field::display(path.as_str()));
                    span.record("query", &tracing::field::display(query.as_str()));
                    //span.record("actor_id", &tracing::field::display(actor_id.as_str()));
                    async move {
                        let hmap = convert_request_headers(&headers);
                        let req = HttpRequest {
                            body: body.to_vec(),
                            header: hmap,
                            method: method.to_string().to_ascii_uppercase(),
                            path: path.as_str().to_string(),
                            query_string: query,
                        };
                        trace!(
                            ?req,
                            "httpserver calling actor"
                        );
                        let read_guard = async { inner.read().await }.in_current_span().await;
                        let bridge = read_guard.bridge;
                        let response = match async { Self::send_actor(linkdefs, req, bridge, timeout).await }.in_current_span().await
                        {
                            Ok(resp) => resp,
                            Err(e) => {
                                error!(
                                    error = %e,
                                    "Error sending HttpRequest to actor"
                                );
                                HttpResponse {
                                    status_code: http::StatusCode::INTERNAL_SERVER_ERROR.as_u16(),
                                    ..Default::default()
                                }
                            }
                        };
                        let mut http_response = http::response::Response::new(response.body);
                        let status = match http::StatusCode::from_u16(response.status_code) {
                            Ok(status_code) => status_code,
                            Err(e) => {
                                error!(
                                    status_code = %response.status_code,
                                    error = %e,
                                    "invalid response status code, changing to 500"
                                );
                                http::StatusCode::INTERNAL_SERVER_ERROR
                            }
                        };
                        *http_response.status_mut() = status;
                        convert_response_headers(&response.header, http_response.headers_mut());
                        Ok::<_, warp::Rejection>(http_response)
                    }
                },
            ).with(warp::trace(move |req_info| {
                let span = tracing::debug_span!("request", method = %req_info.method(), path = %req_info.path(), query = tracing::field::Empty, %actor_id);
                if let Some(remote_addr) = req_info.remote_addr() {
                    span.record("remote_addr", &tracing::field::display(remote_addr));
                }

                span
            }));

        let addr = {
            let rd = self.inner.read().await;
            rd.settings.address.unwrap()
        };
        info!(
            %addr,
            actor_id = %ld.actor_id,
            "httpserver starting listener for actor",
        );

        // add Cors configuration, if enabled, and spawn either TlsServer or Server
        let read = self.inner.read().await;
        let cors = cors_filter(&read.settings)?;
        let server = warp::serve(route.with(cors));
        let handle = tokio::runtime::Handle::current();
        let join = if read.settings.tls.is_set() {
            let (_, fut) = server
                .tls()
                // unwrap ok here because tls.is_set confirmed both fields are some()
                .key_path(read.settings.tls.priv_key_file.as_ref().unwrap())
                .cert_path(read.settings.tls.cert_file.as_ref().unwrap())
                // we'd prefer to use try_bind_with_graceful_shutdown but it's not supported
                // for tls server yet. Waiting on https://github.com/seanmonstar/warp/pull/717
                // attempt to bind to the address
                .bind_with_graceful_shutdown(addr, async move {
                    if let Err(e) = shutdown_rx.await {
                        error!(error = %e, "shutting down httpserver listener");
                    }
                });
            handle.spawn(async move { fut.await })
        } else {
            let (_, fut) = server
                .try_bind_with_graceful_shutdown(addr, async move {
                    if let Err(e) = shutdown_rx.await {
                        error!(error = %e, "shutting down httpserver listener");
                    }
                })
                .map_err(|e| {
                    Error::Settings(format!(
                        "failed binding to address '{}' reason: {}",
                        &addr.to_string(),
                        e
                    ))
                })?;
            handle.spawn(async move { fut.await })
        };

        Ok(join)
    }

    /// forward HttpRequest to actor.
    #[instrument(level = "debug", skip(ld, req, bridge), fields(actor_id = %ld.actor_id))]
    async fn send_actor(
        ld: LinkDefinition,
        req: HttpRequest,
        bridge: &'static HostBridge,
        timeout: Option<std::time::Duration>,
    ) -> Result<HttpResponse, RpcError> {
        trace!("sending request to actor");
        let tx = ProviderTransport::new_with_timeout(&ld, Some(bridge), timeout);
        let ctx = Context::default();
        let actor = HttpServerSender::via(tx);
        match actor.handle_request(&ctx, &req).await {
            Err(RpcError::Timeout(_)) => {
                error!("actor request timed out: returning 503",);
                Ok(HttpResponse {
                    status_code: 503,
                    ..Default::default()
                })
            }
            Ok(resp) => {
                trace!(
                    status_code = %resp.status_code,
                    "http response received from actor"
                );
                Ok(resp)
            }
            Err(e) => {
                warn!(
                    error = %e,
                    "actor responded with error"
                );
                Err(e)
            }
        }
    }
}

/// convert request headers from incoming warp server to HeaderMap
fn convert_request_headers(headers: &http::HeaderMap) -> wasmcloud_interface_httpserver::HeaderMap {
    let mut hmap = wasmcloud_interface_httpserver::HeaderMap::new();
    for k in headers.keys() {
        let vals = headers
            .get_all(k)
            .iter()
            // from http crate:
            //    In practice, HTTP header field values are usually valid ASCII.
            //     However, the HTTP spec allows for a header value to contain
            //     opaque bytes as well.
            // This implementation only forwards headers with ascii values to the actor.
            .filter_map(|val| val.to_str().ok())
            .map(|s| s.to_string())
            .collect::<Vec<_>>();
        if !vals.is_empty() {
            hmap.insert(k.to_string(), vals);
        }
    }
    hmap
}

/// convert HeaderMap from actor into warp's HeaderMap for returning to http client
fn convert_response_headers(
    header: &wasmcloud_interface_httpserver::HeaderMap,
    headers_mut: &mut http::header::HeaderMap,
) {
    let map = headers_mut;
    for (k, vals) in header.iter() {
        let name = match http::header::HeaderName::from_bytes(k.as_bytes()) {
            Ok(name) => name,
            Err(e) => {
                error!(
                    header_name = %k,
                    error = %e,
                    "invalid response header name, sending without this header"
                );
                continue;
            }
        };
        for val in vals.iter() {
            let value = match http::header::HeaderValue::from_str(val) {
                Ok(value) => value,
                Err(e) => {
                    error!(
                        header_value = %val,
                        error = %e,
                        "Non-ascii header value, skipping this header"
                    );
                    continue;
                }
            };
            map.append(&name, value);
        }
    }
}

/// get raw query as string or optional query
fn opt_raw_query() -> impl Filter<Extract = (String,), Error = Infallible> + Copy {
    warp::any().and(
        warp::filters::query::raw()
            .or(warp::any().map(String::default))
            .unify(),
    )
}

/// build warp Cors filter from settings
fn cors_filter(settings: &settings::ServiceSettings) -> Result<warp::filters::cors::Cors, Error> {
    use warp::filters::cors::Builder;

    let mut cors: Builder = warp::cors();

    match settings.cors.allowed_origins {
        Some(ref allowed_origins) if !allowed_origins.is_empty() => {
            cors = cors.allow_origins(allowed_origins.iter().map(AsRef::as_ref));
        }
        _ => {
            cors = cors.allow_any_origin();
        }
    }

    if let Some(ref allowed_headers) = settings.cors.allowed_headers {
        cors = cors.allow_headers(allowed_headers.iter());
    }
    if let Some(ref allowed_methods) = settings.cors.allowed_methods {
        for m in allowed_methods.iter() {
            match http::method::Method::try_from(m.as_str()) {
                Err(_) => return Err(Error::InvalidParameter(format!("method: '{}'", m))),
                Ok(method) => {
                    cors = cors.allow_method(method);
                }
            }
        }
    }

    if let Some(ref exposed_headers) = settings.cors.exposed_headers {
        cors = cors.expose_headers(exposed_headers.iter());
    }

    if let Some(max_age) = settings.cors.max_age_secs {
        cors = cors.max_age(std::time::Duration::from_secs(max_age));
    }
    Ok(cors.build())
}
